# assignment 1

### 软件开发本质难题

从软件发展的三大历史阶段以及软件过程的演变当中，我们可以总结出哪些规律性的东西？

* 复杂性
* 不可见性
* 可变性
  * 需求、技术等导致的可变性
* 一致性
  * 向上、向下兼容
  * 开发时需要保持一致性

### 软件发展三大阶段

随着时间得推移，软件所占得比例越来越大（相比于硬件）

1. 软硬件一体化阶段（50 - 70年代）

   软件完全依附于硬件，二者无法区分。软件仅仅是为了让硬件可以工作

   软件作坊：软件依然严格依附于硬件

2. 软件成为独立的产品（70 - 90年代）

   软件不依赖于硬件，而是单独的产品。

   有很多重合的部分

3. 网络化和服务化（90年代至今）

### 第一阶段：软硬件一体化阶段

#### 早期：软件完全依附于硬件

##### 软件应用典型特征

* 软件支持硬件完成计算任务
* 功能单一（一般也就是一些计算）
* 复杂度有限
* 几乎不要需求变更（硬件一般不容易变化，因此需求也不太容易变更）

（注意对比，软件开发的四个本质难题：复杂性、不可见性、可变性、一致性）

##### 软件开发的典型特征

* 硬件太贵
  * 软件工程师使用硬件来完成计算时，硬件的成本远远高于软件开发者。开发时希望软件开发完成之后确保全部正确再去硬件上运行，不能支持服务器调试（成本过高）
* 团队以硬件工程师和数学家为主

##### 典型流程和实践

基本是线性的顺序过程。这是匹配软件应用和开发的一种方式。

Measure twice, cut once. 做木工的时候，木料特别贵，那么一定是左右都量一遍才去切割。也就是说，软件运行之前要惊醒反复的确认。希望软件工程师反复得确认之后再去运行。

#### 后期：软件作坊

60年代末

##### 软件应用典型特征

* 功能简单
* 规模小（比如电子表单）

##### 软件开发典型特征

* 有很多非专业领域人员涌入软件
* 高级程序语言出现——非专业人从事软件开发成为可能。
* 质疑权威的文化盛行

##### 经典软件过程和实践

Code and fix. 编码加改错。

事实上这不是一个好的做法：不管三七二十一先写再改。

事实上在任务不是很复杂又有高级语言的情况下，当时也是比较合理的。

### 第二阶段：软件成为独立产品

#### 软件应用开发典型特征

* 软件摆脱硬件的约束（操作系统出现）
  * 软件拜托了硬件的束缚，只需要和操作系统进行交互。
* 功能强大
  * 硬件的计算能力水涨船高
  * 软件相应功能增强——规模和复杂度增加
* 个人电脑出现
  * 普通人成为软件用户（以前，用户是专业人士）
  * 需求多变（普通人很多、种类也很多，需求复杂多变）
  * 兼容性要求（需求多变，软件频繁更迭版本）
* 来自市场的压力
  * 存在一些公司专门做软件
  * 实现类似功能的厂商存在竞争，因此需要更快得将产品推向市场。软件开发的生产效率有比较高的要求

#### 典型软件过程和实践

* 形式化方法
  * 主要解决质量问题（正确性）
  * 使用具有极高的要求，需要开发者的很高数学基础。应用范围比较窄。现在只是在一些关键领域被应用。
* 结构化程序设计和瀑布模型
  * 对于大型的系统（比如操作系统），编码加改错是失效的（六十年代末的软件危机），软件工程因此被提出
  * 结构化：解决复杂问题的通用方法。
  * 和现代的主流方法比较类似。

### 第三阶段：网络化和服务化

#### 软件应用特征

* 功能非常复杂、规模非常大
  * 已经很难界定软件的规模了。比如淘宝，已经很难清晰定义其边界
* 用户数量急剧增加
  * 几百万、几千万、几亿的用户数量
* 快速演化和需求不确定
* 分发方式变化（SaaS）
  * 软盘、光盘——software as a service, 基于网络的方式，服务端进行更新，客户端就能直接使用。

#### 典型软件过程和实践

迭代式：大型软件系统的开发过程也是一个逐步学习和交流的过程，软件系统的交付不是一次完成，而是通过多个迭代周期，逐步来完成交付。

不特指某种，而是泛指一类的方式。在90年代中后期一直到现在。

### 更深的网络化和服务化

#### 软件应用典型特征

* 软件随处可见
* 用户需求多样性进一步凸显
* 软件产品和服务的地位变化
  * 早期（十年前），软件是可有可无的，生活照旧；如今，没有软件和软件的服务，人们的生活是寸步难行的。软件和服务从可有可无变成了核心。
  * 因此，如今的软件，如果崩溃了一天、两天，就已经是无法接受的事情了（想象淘宝崩溃一天）
* 错综复杂的部署环境
  * 因为已经有很多正在运行的信息化系统，加入新的软件系统就要面临复杂的部署环境。
  * 比如，如何平衡软硬件资源
* 近乎苛刻的用户期望
  * 多：功能丰富
  * 快：快速使用、及时更新。软件行业的摩尔定律：每18个月，功能翻倍、获取成本下降。这对软件和服务的提供者提出了挑战。推迟十八个月再上线，则带来的价值显著下降
  * 好：稳定可靠。7/24可用的服务。
  * 省：用户获得成本低、最好免费。
* 空前强大的开发和部署环境：
  * XaaS
    * IaaS：基础设施即服务（服务器可以由云计算厂商提供）
    * PaaS：开发平台即服务
    * SaaS
    * FaaS：功能即服务
  * 开源和共享文化
  * 盛行敏捷——快速价值交付
  * 软件工程能力的潜在支撑力量有所长进（AI，大数据，云计算）

# 团队动力学

### 自主团队的外部环境

知识工作者无法被领导

领导：学会激励

软件工作必须是自主管理，自主团队需要管理层支持。管理由团队本身来管。

#### 项目启动阶段获得管理层支持

* 计划中体现出定期向管理层报告
* 证明工作计划合理

* 变更
  * 不允许随意变更（糟糕的工作计划），一定是要有约束，比如哪个阶段允许变更。就算是敏捷社区。scrum的sprint中，只记录，不响应。这是对变更有所约束。
  * 也可以是，比如人员不变更
* 向管理层请求必要得帮助
  * 让管理层放心，新任开发团队自主开发

通过让管理层放心实现团队得自主性

#### 项目进程中获得管理层支持

* 严格按照定义的开发过程开展开发工作
* 维护个人和团队的工作计划
  * 动态的，满足项目的进展
  * 现实中变更计划是常见的，因此计划需要更新来反映项目的客观现实
  * 计划可以维持激励作用，维持管理层支持
* 对产品质量进行管理
  * 报告质量活动，质量状态
* 跟踪报告项目进展
* 持续展现优异的项目表现
  * 项目没有持续展现优异的表现（顺风顺水），那么可能导致被拉回来的项目团队得到奖励，顺利的反而被认为是简单的项目
  * 为了获得管理层的持续支持，要持续报告优异的表现

通过持续得汇报来获得管理层得认可

### TSP对自主团队的支持

Team Software Process

对应于PSP

同时关注团队和个人

PSP的个人能力是管理的技能（个人的管理）估算、开发计划等。项目经理无法指定开发计划（不是自我管理）。在技术技能之外要具有管理的能力

TSP 团队组建过程

#### TSP团队组建过程

分为若干次会议，和项目的情况相关

管理层提出具体需求，时间、资源、功能等要求，针对这些要求团队给出解决方案。

完成第一个团队的工作，平衡、妥协来完成一件事情，一个良好的开端

##### 第一次会议 ：建立产品目标和业务目标

产品目标（功能上的）、业务目标（管理层的事，为什么要做这个产品，对公司业务有什么影响）

项目经理要带领团队问问题、充分沟通，为什么要有这个功能，为什么要在这个时间交互。

之后的所有计划要做出各种妥协，时间永远是不够的。

了解需求、了解需求背后的动机和原因。

比如，半年之后对手已经上线了，那么不符合业务目标则项目无意义。“对手两年前就进行规划了，那么问题不在开发团队”。通过这种讨论，大家能对业务目标达成共识。

##### 第二次会议：角色分配和小组目标定义

兼顾客户目标（产品 业务），让开发团队人员目标

可能一样：成功的项目

可能不一样：希望通过项目得到技术、质量管理、项目管理等节能上的锻炼（管理层不care）

可能对立：尽快交付产品，投入尽可能对的时间 vs 希望平衡工作和家庭（不想加班）

要定义出项目团队的目标，对于对立的目标要在会议中解决

##### 第三次会议：开发流程定义和策略选择

定义开发流程——选一个生命周期模型，给出开发流程的主框架，然后细化每个步骤，适应项目的上下文

定义开发策略——比如，几个迭代，每个迭代分别做什么；分成多个模块，每个模块如何获得；开发的整体技术框架

##### 第四次会议：整体计划

对应整个项目，项目阶段什么时候开始结束等。

##### 第五次会议：质量计划

质量管理（后面讲）

要做哪些质量活动，比如，哪些评审

做到什么程度，如，花多少时间进行评审，花多大经历做。做几轮测试

做哪些、做到什么程度

##### 第六次：个人计划以及计划平衡

和第四次的区别是，后者没有安排到具体人员，只是预计多少时间。前者把定下的任务和开发团队的人员做出安排。

平衡：尽可能保证大家同时完成工作。比如，评审是所有人都要参加的；有的活动如单元测试是个人活动。如果不做平衡，则大家结束时间是参差不齐的。这样可以让团队认为计划更加可信。

##### 第七次：风险评估

对风险越了解则越对项目有透彻的理解

##### 第八次：准备汇报

##### 第九次：汇报

##### Launch阶段总结

#### TSP角色

leader（组长）：指导方向

经理：规划管理日常事务

所有的团队成员都具有管理权限，增加责任感归属感，也让TL主要关注方向

##### 项目组长 Team Leader

* 建设和维持高效率的团队
* 激励团队成员积极工作
* 处理成员的问题；比如，技术冲突的解决，所以项目组长要懂一些技术
* 向管理层汇报信息
* 会议组织和协调

##### 计划经理

* 开发完整的、准确的团队计划和个人计划
* 报告项目小组状态

###### 主要工作

* 带领指定开发计划
* 带领平衡计划
* 跟踪项目进度
* 参与项目总结

##### 开发经理

技术带头人

* 开发优秀的软件产品
* 充分利用团队成员的技能

##### 质量经理

协调组织有效的评审

##### 过程经理

* 带领团队定义和记录开发过程并支持过程改进

  对应第三次会议（开发流程的定义），主持此次会议

* 建立和维护团队的开发标准

  开发标准包括：编码规范、接口定义标准、模块命名、模块划分等的标准。

* 记录和维护项目的会议记录

* 参与项目总结

##### 支持经理

整个项目团队的工具、环境的专家，维护开发工具和开发环境

* 确保项目开发中合适的工具和环境（工具的集合，DevOps的工具链）

  怎样用好这些工具。例如一个熟悉的人来做CI。

* 对基线产品，不存在非授权的变更。

  稳定的产品（代码、文档），如果再次修改必须要走一个变更的流程，要经过支持经理的授权。

* 项目小组的风险和问题的跟踪

* 确保项目小组开发过程中要满足复用目标

  软件复用可以事先设定目标。design for reuse. 为了复用来做设计，在设计时候就考虑复用，挖掘复用的机会和潜力。这样可以在后面的迭代中找到复用，而不是纯靠运气。

###### 技能

* 对开发工具感兴趣，熟悉使用场合。
* 熟悉版本控制，熟悉配置管理流程
* 对所有项目使用的工具都是专家

###### 工作

* 带领团队识别开发中需要的工具和设置
* 主持配置管理，管理配置管理系统。
* 维护软件项目的词汇表（提供对复用的支持，让别人知道以前有没有类似的模块）
* 维护项目风险和问题跟踪系统
* 支持软件开发中复用策略的跟踪
* 项目总结

### SCRUM小组角色

* 产品负责人（一人）
* 开发团队（多人）
* SCRUM Master

跨职能的**自组织**团队

#### 产品负责人

产品价值最大化

管理产品的待办列表。不是功能清单，也可能是以前错误的修改，可能是改一个功能，等等。scrum中只同一sprint记录变更不进行修改，就是在这里进行记录

 * 清晰表述待办列表

 * **对待办列表定义优先级**

 * 优化所执行工作的价值。

   通过做什么、什么更优先，来体现

   这和TSP中leader指引方向是相匹配的。
   
* 确保产品待办列表对所有人可见、透明、清晰

#### 开发团队

负责每个sprint结束时交付产品负责人提出的要求实现。

产品负责人确定做什么，开发团队负责怎么做（过程、方式的权限在开发团队）。

* 没有人规定开发团队如何把开发列表实现

  TSP中，开发策略也是团队来定义的（第三次会议）

* 开发团队时跨稚嫩搞得团队，作为一个整体，拥有开发产品增量所需要的全部技能

* 向下不认可子团队，但是向上认可更多的scrum的团队。一个scrum的人数不要超过20人

* 每个人领域特长不同，但是团队整体负责

#### SCRUM Master

类似于过程经理。

促进和支持SCRUM

让每个人理解SCRUM

服务型领导，让团队外的人知道如何和团队交互

# 估算、计划、跟踪

项目管理

* 估算
  * PSP
  * PROBE
* 计划和跟踪
  * 团队项目规划
  * 团队项目跟踪和管理
* 项目总结

## 估算

### PSP

全面质量管理的思想：过程的质量决定了产品的质量

**个人级**管理实践和过程估算和计划

承诺和拒绝承诺（自主团队，承诺驱动）

理解和改进

工业水准的过程和规范（形式化手段）

客观决策的数据

### 什么是PSP

* 记录表格、过程操作指南、规程的结构化框架

* 策划、设计、编码、编译、单元测试、总结等阶段

  一个模块级别的开发，应用PSP。

* 每个阶段有过程操作指南，详细定义

* 开发活动有日志

### PSP基本原理

* 系统整体质量由最差的组件决定（木桶原理）
* 组件质量取决于开发软件的工程师和其开发过程
* 合格的软件工程师应该自己度量、跟踪自己的工作，管理自己软件组件的质量
* 要学习总结、自我改进的能力

### PSP的不同级别

生命周期 = 软件开发过程（更加粗粒度的）

在原来的过程元素上加一些东西

PSP 0 0.1 1 1.1 2 2.1 

PSP 3.0 == TSP（大环境是TSP，每一个个体是PSP，自定义的个体过程）

PSP2中开始要求做review

### PSP过程度量

度量体现决策者对试图要是心啊的目标的关键程度

是否要度量却决于是否重要。

* 规模
  * 没有规模数据，则历史数据都是没有意义的。
* 时间
* 缺陷
* 日程（TSP）

## PSP 时间度量（时间日志）

为什么要用这种方式？

时间是为了做估算，通过历史时间估算未来。

日志关联于任务（记录阶段），这不是企业中没有的，例如工作日报、工作周报，其写法大概是，上午 1 2 3 4 ，下午…… 

PSP是以任务关联时间，而日报是以时间关联任务（先规定了时间的间隔划分）。效果上来说，就是能否建立估算的信任感。

未来的时间能够确定的只有一部分（突发事件、会议）等，如果不能排除则无法建立有信任感的估算。

考虑1. 任务需要多少时间 2. 在日程表上具体需要多少天（日程表上如何提供这些时间）

这里需要考虑，任务的时间应该是纯粹的任务时间，而不是加上邮件、会议等的时间算在其中。要保证估算的时间纯粹是目标任务。再去估算每天的有效时间，这才更可信。如果不考虑任务纯粹时间，和日程能够分出的时间，那就损失信任感。

结果不重要，重要的是愿不愿意相信

因此，工作日志的方式才能估算出纯粹的任务时间，才能建立有信任的估算。

按照企业的方式是无法提供完成某任务的纯时间。两种方式的记录成本差不多，但是可用性差。

另外备注信息如果统计一整天的话，有可能得到一天的有效时间。得到真实的有效时间。了解为什么有的人有效时间低。

强调目标的达成应该关注有效时间。例如，已经每天5、6小时的有效时间，那再搞安静时间开发也没用

## PSP 缺陷度量（缺陷日志）

消除阶段不能早于注入阶段，但可能是同一阶段。注意是阶段不是日期，因为更在意在哪个阶段。

单元测试阶段也会引入缺陷，如在修改某缺陷时产生新的缺陷。

注意要记录根本原因而不是症状。症状只在当前项目的上下文中有意义，脱离这个项目则没有意义。比如，“点击某按钮会报错”是症状，根本原因是“某点操作没有判断是否为空”。后者作为根本原因，脱离项目依然有意义。记录的目的是为了防止未来缺陷的发生（缺陷预防），主要就是预防自己经常范的错误。

在不同的阶段容易犯什么错误也可以获得

## 规模度量

### 困境

* 精确的度量方式在项目早期无法使用。需求还没明确，如何确定有多少行代码？这是不可能的

* 有助于早期规划的度量往往没有产生精确的结果。比如功能点不能产生精确的度量，因为没有标准的功能点的粒度。

精确的度量又是越早越好，因为要通过规模度量来做计划和估算。

代码行：精确，但是在项目早期没法用

功能点：模糊，但是在项目早期能用。

能否兼顾？PROBE

PROBE是一个桥梁，让精确的度量和项目早期建立换算。

PROxy Based Estimation

通过相对大小矩阵将模糊映射到具体

代理识别（几个相对多大的房间）通过相对大小矩阵获得代理规模（总共多大）

调整程序和资源（人）的规模。

线性回归调整规模估算

E之给出了房间内部的面积，但是对应走廊的面积不确定比例如何。对于代码来说，也是只估算了方法内部的代码，方法外部的代码（声明等）是没有被估算的，这部分也是非固定比例，只能通过线性回归来进行。每一个新的估算基于历史数据来估算这个由于非固定比例导致无法估算的结果。

计算回归系数的是，x：历史项目的 E，y：历史项目的真实开发时间。由此来做线性回归。注意区分 actual time and plan time

预测区间：区间估计而不是点估计。

### 通用计划框架

和PROBE的差别是资源估算和规模估算是否是并行的。资源估算的一个输入时规模估算，再加上生产效率。

这里的资源估算和PROBE的资源估算有什么区别？为何PSP作此选择？

PROBE不考虑生产效率，只考虑线性回归（probe到真实的映射）

主要是，效率作为分母，其波动比较大。通过绕开生产效率，避免了“人”这种不确定性的波动出现在分母上（放大波动）。本身规模就是一个区间，效率也是一个范围。

项目中的 proxy size 到 actual time 有错综复杂的因素。说白了，两次的误差叠加会导致更高维的误差，还不如直接进行数据的估计。多种因素下，只能去建立线性回归关系来预测。只要能通过相关性检验就可以用，不必在意影响。这样来看 PROBE 更加准确。

当然，如果没有历史数据，就只能根据规模生产效率算资源，因为没有历史数据。数据多了之后再用线性回归的方式。

#### 为什么用这种方式

让可变的（可讨论的）基本只有1. 模块的划分 2. 资源的提供。 因此，如果管理层不满意，那么就只有两个点，要么重新与团队定义需求，要么增加更多的资源。比较糟糕的情况是，外行人纠结于到底这个是多少行代码，这样最终的计划产物是双方都可不信的，那么这样的计划就没有意义。

### 三种方法对比

一般使用对数。1. 更符合人的直观感觉（大量小模块的少量大模块）2. 不会出现负数

简单方法：计算简单；少量数据可能造成巨大差别（比如一个不合理的极小值或极大值）；不稳定，导致不可信

正态分布：可能出现负数，让人不理解

### 有限历史数据

1. 历史数据可能很小（小于3）
2. 历史数据多但是数据质量差

如何处理？

#### 相关性

两组数据的相互关联程度

PSP为了确保估算质量，要求历史数据相关性 r >= 0.7

#### 显著性

两组数据相关关系的偶然程度

显著性越小越好（相关关系的偶然程度低，关系可靠）

PSP要求显著性 s <= 0.05 (误判的概率小于5%)

软件工程中，大量的都是**相关性**而不是**因果性**。例如，有时候可能加了测试质量反而变差，如果用因果描述就无法解释，但是用相关性描述就是合理的。

### PROBE估算规模

#### B方法

三组以上，计划规模和实际规模

通过相关性检验（ r s ）

AB对于数据的质量要求是一样的，差异在于用来分析对比的数据

永远都是DCBA的方式逐渐进行。

### PROBE估算时间

问题：为何这里又用到了历史效率？

B0只是数据质量的要求，和计算没有关系。

### 极端数据

少量的极端数据可能导致相关性的错误（本来不相关的数据显得相关）

因此这里要通过显著性来计算，判断相关性的偶然程度。

### 对估算的反思

估算到底是为了准确还是为了可信？

可信 != 准确

就算估算结果最终糟糕，但是人们仍然相信，那么这种估算仍然是好的。

生产效率能相差26倍，那么估算偏差在26倍以内，岂不是也能接受？

总之，估算的主要目的是通过一个挑不出错误的方式，让各方达成一致，对估算结果“信任”，至于这个结果到底是否正确，就无所谓了。就算估算很准，没有偏差，但是人们不相信，那么这个估算就是毫无意义的，因为它对于项目的进行没有正面作用。

估算时间、规模一致，两种情况，是否能够说明估算准确？估算不管是否准确，只管是否可信

## 计划

### 工作分解结构

WBS: Work Breakdown Structure

划分标准用什么都可以（开发阶段、功能模块），但是要求在同一层不要使用多种方法。可以比如，第一层是模块划分，第二层是开发阶段，这样是可以的。Q：应该只是兄弟吧？

经验上认为大概 7 +- 2 层。

#### 作用

* 范围基线

* 整体观

* 不遗漏交付物

* 明确各角色责任

  WBS要求每个叶结点是独立的工作包，可能是一个人一周来完成，也有可能是由一个团队来进行。如果是个人的工作则要求一星期。

* 工作包定义

* 估算和计划的基础

* 理解工作、分析风险

#### 创建WBS

* 识别和分析可交付成果和工作

* 确定工作的划分（工作类型 or 模块 or 阶段）

* 自上而下分解

* 分配标识符和编码

  WBS 是讨论出来的，用这个来记录讨论的共同的决策。通过这个标识符来避免图上信息过多，搞一个数据字典。

  强调：WBS 不是一个人做出来的，二十大家讨论的共识。

#### 好的 WBS 标准

* 层次合适：太少说明没有想清楚，太多则过于繁琐。

* 叶节点不能重复

  任何一个工作包只能在一个地方出现

* 清晰完整的定义（数据字典）

* 最底层有清晰负责人

* 最底层要素是实现项目目标不可缺少的部分

  开源软件思想：好的软件不是越多越好，而是不可缺少。

#### 范围管理

通过 WBS 给出项目的范围，为范围提供了标准。

WBS 和需求分析、项目计划谁在前谁在后？顺序如何？

WBS 是项目计划的一个活动。计划和需求分析

* 收集需求
* 定义范围
* 创建 WBS
* 核实范围
* 控制范围变更

项目都是有需求分析的阶段，它存在于一个日程计划，这个日程计划是估算的结果。

先做需求，但是这个需求仅仅是为了帮助理解工作内容，不是真正的需求分析，只需要这个需求足够进行估算。真正的需求开发不仅仅是客户需求，还包括设计者的需求，实质上是一种设计。

有了 WBS 并不代表拒绝变更，它只提供范围的基线，这也是可以改的。对于范围的变更，需要**控制**、管理

#### 开发策略和计划

基本策略：几个迭代、每个迭代做什么、每一个功能通过什么方式获取（自己开发 or 第三方获取）、组件的关键技术栈

## 跟踪

### 挣值管理方法

100%完成则获得价值

如果工作包太大，则进度跟踪没意义。0-100情况要限制工作包大小

单纯软件项目开发，可以把金钱改为时间（软件的成本、资源）。把工作包放在日程表上排为计划，日程计划上有应该以什么速度、节奏获取对应的价值，这就是一个**进度计划**，也呈现了成本计划。把进度时间除以总时间，得到当前进度的百分比。

所以总共看到三根线：挣值、预算、成本

如果重合在一起说明计划与实际一样

挣值和计划的差是进度差异。

#### 简单实现

如果只考虑PV（BAC） EV，则称之为“简单实现”。

有别于传统项目管理：

传统项目的跟踪关注关键路径，找到最长的长度叫做关键路径，认为关键路径上活动的延期等于项目的延期；软件项目认为，前面的延期了，为什么不认为后面的项目不会延期？由于软件的可重复性不如传统项目（例如，修路，前10公里和后10公里的估算差异应该是差不多的）

另外如果考虑软件项目的变更，那么按照传统的方式无法跟踪进度。比如，砍掉功能会让进度提前，但是新功能让进度变低。仅从某时间节点任务是否完成来判断，是不可以来由此跟踪进度的。

差异（SV）由延迟时间来判断。（延期）

把挣值曲线延长可以推算项目总延期时间（这样也计算了后面的延误，进行了放大）

#### 高级实现

把实际成本加进去，描述实际上投入了更多的成本（高于预算）

这描述的是，这个项目1. 进度慢 2. 成本超支 这是非常糟糕的情况。

把成本曲线延长来估计可能的成本超支情况。

某任务删除，则其他的任务的百分比提升，已经完成的进度呈现出上升。加入任务，已经完成的任务价值下降。

例子中项目团队低估了项目难度，花费了更多时间，单位时间获取的价值比计划低（隐患），但是项目总体进度完成了90%，所以还可以

说明挣值管理可以非常好得体现项目得进度情况。

#### EVM的变形——燃尽图

EVM是从零开始，燃尽图是从100开始（未完成的价值的变化）

燃尽图也可以来进行预测。

注意这里还是要求 0-100 规则（完成的全部获得），这是一种保守的方式。激进的可以是 50-50 规则，比较乐观，开始就算50%。

#### EVM的局限

不能支持软件的质量管理

非常依赖于估算的准确：如果对于价值的估算错误，则进度是完全失效的。

### 里程碑评审

进度评审是项目团队内非正式的（是否符合计划）

里程碑评审是包括团队外，如用户、高级经理参与，正式的评审。

### 其他计划跟踪

如果有一个计划，就需要进行跟踪。如，日程计划跟踪、承诺计划跟踪、风险计划跟踪……

### 纠偏活动的管理

跟踪发现问题之后，要对应得进行纠偏，定义对应得措施，和偏差原因是相关得。

比如，发现已经加班了（投入时间比预计时间多了），那么挽回进度就不能再通过加班，只能是（比如）增加更多得资源。

## 项目总结

持续改善对于软件工程师很重要

### 范围管理

未被识别的需求

需求蔓延

### 时间管理

### 成本管理

指派不同的人员从不同来源收集资料，汇总信息，不弯曲那是项目经理来进行

### 质量管理

### 人力资源管理

# 质量管理

重要性：从质量当中追求效率、成本

> People are happy to do it wrong and invest the time to fix it, which sometimes never works, as opposed to investing the time to get it right the first time. 
>
> —— Watts S. Humphrey

人们喜欢花时间改正，而不是在最开始就保证没有错误。

### 内容

* 质量策略
  * 管理对象
  * 基本策略
  * 评审过程
* 设计与质量的关系
  * PSP 设计过程
  * PSP 设计模板
  * PSP 设计验证方法

### 软件质量定义

* 与软件产品满足的规定和**隐含**的需求能力有关的特征

  例如，要满足法律法规……

* 分为内外两部分特征：外部质量面向用户，内部质量不面向用户

  能感知到的，如快慢、交互友好程度，即用户可感知的。

  内部质量：框架、可复用性、可维护性、可扩展性……面向开发者。

* 软件质量是软件产品可改变世界，使世界更加美好的程度。从**用户视角**考察，用户满意度使最重要的判断标准

* 软件质量为对人（用户）的价值。这一定义强调了质量的主观性，即对同一款软件而言，**不同的用户**对其质量有不同的体验。 

  这么多的用户，如何判断质量如何？另外本身就是主观的，如何管理？

管理三要素：目标、状态、纠偏。

如果不同用户由不同的质量体验，则管理三要素中，目标、状态都无法确定。

### PSP 质量定义

面向用户的视图，定义为满足用户需求的程度。

需要讨论以下问题：

* 用户是谁？

* 用户需求的优先级⭐

  满足需求的程度，需要区分优先级

  基本的假设：不可能 100% 满足用户的需求。因此，讨论优先级是必要的。很可能在某些方面要进行取舍。

  如果给无限的资源，那么这一切都是不需要考虑；正因为资源有限，故要有所妥协，根据优先级进行取舍、妥协。

  几乎所有情况下，最高优先的是功能正确。
  
* 客户优先级对软件开发过程产生的影响

* 如何度量这种质量观下的质量水品

#### 典型用户期望

* 最**基本**的：能工作
* 快速
* 安全性、保密性、可用性、可靠性、兼容性、可维护性、可移植性……

当涉及到质量**管理**时，很多这些质量都要舍弃。可以通过质量**活动**来提高，但是**管理**要求三点。

单纯要求质量管理是做不到的

### PSP 质量策略

* 用缺陷（defect）管理来代替质量管理

  将不可行的事情变为可行。不这么干，就无法进行质量管理。

  面向用户的质量观告诉我们，无错误是最重要的。

  无缺陷，是其他质量属性的前提：错误百出的软件，如何保证安全、性能？

* 高质量产品意味着组成软件产品的各个组件基本无缺陷

* 各组件的高质量是通过高质量**评审**来实现的

  有无限的资源，随便怎么搞；正因为有限，所以用评审来更高效得进行。

bug：对错误的结果有预期的，且能接受它。可感知的。

defect：导致什么后果，是不知道的。如地址越界。

所以一般用 defect （缺陷）来表示。

### 不同方式消除缺陷的效率

review：自己看

inspect：小组评审

图中可以看到：

1. 最好自己进行评审（个人评审效率最高）

   ”思维定势“？事实上，理解别人的代码并找错误是更加困难的。

   发现错误的前提是理解。

2. 要将缺陷限制在**模块内**

   系统测试的效率极低（1405 分钟，一个软件工程师一个星期的时间）
   
3. 尽管如此，评审**不可以**代替系统测试

   只是说明，不要过于依赖后期系统测试（成本太高），但是必须注意，现实生活当中，不是所有错误都可以通过评审、系统测试消除。不可能有手段保证消除所有的错误。

事实上在编码完成之后，所有的

### 消除缺陷的典型流程

* 发现异常行为
* 理解程序工作方式
* 调试程序，定位，确定原因
* 确定修改方案并修改
* 回归测试，确定修改有效

其中，调试、定位是最困难的工作。

某些程序可能根本无法调试，只能”瞪“。

### 评审发现缺陷的典型流程

* 遵循评审这的逻辑理解程序流程
* 发现缺陷的同时，也知道了缺陷的位置和原因
* 修正缺陷

评审消除错误的代价相比测试，是低很多的。

注意，**并不是评审可以代替测试**。只是说，能在上游消除，则尽量在上流消除

除了净室软件工程中，算是一种替代。

### PSP评审过程质量

* 建立评审检查表

  完整的、个性化的检查方式。

  例如，变量声明需要初始化。

  对检查表上的每一项需要进行检查。

  发现养成了习惯，就进行修改（个性化）。

  来源：**缺陷日志**。由于其中包含了缺陷的**根本原因**

* 质量控制指标

* 其他因素

  * 环境、评审时机、个人评审和小组评审、缺陷预防

### 质量控制指标：Yield

每个阶段在消除缺陷方面的效率

#### Phase Yield

$$
\frac{某阶段发现的缺陷个数 }{ 某阶段注入的缺陷个数 + 进入该阶段前遗留的缺陷个数}\times 100\%
$$

用来表示每个阶段的缺陷消除效率

|      | Inject     | Remove | Remain      | Yield | 估算                |
| ---- | ---------- | ------ | ----------- | ----- | ------------------- |
| DLD  | 10 **+ 4** | 0      | 10 **+ 4**  | 0%    | **0**               |
| DLDR | 0          | 6      | 4 **+ 4**   | 60%   | **6 / 14 = 42%**    |
| CODE | 20 **+ 8** | 0      | 24 **+ 12** | 0%    | **0**               |
| CR   | 0          | 12     | 12 **+ 12** | 50%   | **12 / 36 = 33.3%** |
| UT   | 0          | 12     | 0 **+ 12**  | 100%  | **50%**             |

问题：并不知道上一个阶段遗留的问题数量。只能进行估算

估算的基本假设：最后一次干掉50%。等比例得加到之前阶段的注入，然后计算实际 Yield 的估算值，只有这个估算值是有参考意义的。

表中加粗的是在假设最后一次实际 Yield 为 50% 的前提下进行的估算。

#### Process Yield

$$
\frac{第一次编译前发现的缺陷个数}{第一次编译前注入的缺陷个数} \times 100 \%
$$
Yield 就是一种“过滤”，在计算过滤缺陷的效率

通过**缺陷日志**（记录了注入阶段、消除阶段），就可以知道每个阶段注入、消除的缺陷。

#### 作用

知道各阶段 Yield 的意义：从质量管理角度，Yield 是非常有用的，如果缺陷密度比预期糟糕，就知道了改进的重点在哪

一般要求 50% 就可以，但是考虑到如果每个阶段都 50% ，其实整体的将结果还是比较好的。

告诉我们改进的机会。

Yield **只能估算，不能度量**。因为遗留的缺陷数据是不知道的。

### 质量控制指标：质检失效比 A/FR

DLDR + CR / compile time + UT

$$
\frac{DLDR + CR (质检成本)}{compile\space time + UT(失效成本)}
$$
横坐标：质检失效比

纵坐标：缺陷密度

基本的达到 2 之后就没什么错误。

A/FR **可以度量**

#### 作用

* 判断某模块的质量状态

  了解质量状况，管理分配资源（质量低的需要更多测试），规划质量实践

  * 测试策略

    大爆炸，step by step

    每个模块质量高时，big bang 效率最高

    大量模块质量差时，big bang 难以定位错误

    所以了解模块质量很有用

* 规划质量计划

  模块时间估计之后，还需要分配具体的时间

  部分跟质量有关的实践的资源分配可以以此为依据。

### 质量指标：PQI

过程质量指标 Process Quality Index

既有过程又有结果数据

以下五个数据的乘积

* 设计质量：设计的时间应该大于编码的时间

  $$
  Min\{\frac{DLD}{CODE}, 1\}
  $$

* 设计评审质量：设计评审的时间应该大于设计时间的 50%
  $$
  Min\{\frac{DLDR \times 2}{DLD}, 1\}
  $$

* 代码评审质量：代码评审时间应该大于编码时间的 50%
  $$
  Min\{\frac{CR \times 2}{CODE}, 1\}
  $$
  
* 代码质量：代码的编译缺陷密度应当小于 10 个/千行
  $$
  Min\{\frac{20}{10 + UT}, 1\}
  $$

* 程序质量：代码单元测试缺陷密度应当小于 5 个/千行

  $$
  Min\{\frac{10}{5 + UT}, 1\}
  $$
  

前三个是过程指标，后两个是结果指标

任何一个是 0 结果肯定是 0

横坐标 PQI，纵坐标缺陷密度。随着 PQI 增加，缺陷密度下降，PQI 到 0.4 之后基本就没有缺陷。

#### 作用

* 判断模块级别的开发质量

* 帮助做质量规划（规划）

* 为过程改进提供依据

  哪个差就加哪个

### 质量指标：评审速度

PSP 要求速度小于 200 LOC/小时（一般正“常”评审时间的十分之一）

### 质量指标：DRL

Defect removal lavage

$$
\frac{某阶段每小时消除的缺陷数 }{UT}
$$

单元测试消除缺陷效率是差的，希望大于等于1

### 其他因素

* 打印后评审效率更好

  脱离工作环境，避免工作环境影响。

* 评审时机选择

  先编译还是先评审？

  编译器在 review 前后发现错误的能力是一样的，评审的目的是找出**所有的错误**，则代码是否编译过，**评审消耗的时间是几乎一样的**（也包括单元测试）。但是 review 是有机会找语法错误的，找到语法错误则可以缩短编译时间。即，先编译不减少 review 时间，先 review 减少编译时间。但是前提是 review 要试图找到所有的错误。

* 个人评审、小组评审

  先个人评审，后小组评审，对别人的投入的尊重。（不要给别人垃圾看）

  传统上基于历史数据作为标准，比如，本次评审发现错误和历史错误数差不多，说明评审得，但是这是有问题得，是基于材料得质量水平、消除缺陷的能力是稳定的，然而这通常不成立。九宫图基于，材料质量、消除缺陷能力相对稳定。

  类似于，标记重捕法来预测——capture-recapture. 和历史数据无关

  近似：独立发现缺陷最多的是A，剩下的作为整体是B。人数越多，越可信

### 追求极高质量的手段

* 各种测试

* 进入测试前的产物质量提升

  garbage in garbage out. 

  测试不是提升软件质量的手段，而是检验软件质量状态的手段

* 评审过程度量和稳定（指团队形式的评审）

  Yield 像个滤纸，这里需要让 Yield 非常**稳定**，稳定则能够保证，多几层滤纸（多几次评审），结果非常可靠、稳定。稳定就是保证评审过程每次这个百分比差不多。

  保证稳定的方法就是过程度量。

* 质量意识和主人翁态度

  大家都为质量负责

* 个体 review 的度量和稳定

  和 step 3 同理。

  个人评审应该在团队评审之前。

* 诉诸设计

  从 step 3 开始，不再是找错误改正，而是从一开始就避免错误。

* 缺陷预防

  例如，根因分析（找到问题的根本原因）。

* 用户质量观——其他质量属性

  缺陷之上，其他的质量属性。缺陷解决之后，有精力解决其他问题，比如性能、安全等。

为了更高的质量，有多种、多层次的手段。有顺序的，比如最开始就从测试开始。先后顺序是必须的，先做后面的是非常不合理的。

### 设计与质量的关系

* 设计是一个排错过程

* 充分设计可以显著减少程序规模，提升质量

  言多必失。

### PSP 设计过程

（图）

设计不是线性的，是循环往复的过程。

这不是试错。这是找到更准确、清晰的意图。

#### 设计什么

* 目标程序在整个应用系统中的位置

* 目标程序的使用方式

  用例、用例图。需求阶段产生，但其实是个设计

* 与其他组件和模块间的关系

* 外部可见的变量和方法

* 内部运作机制

* 内部静态逻辑

#### 设计的内容

|          | 动态信息               | 静态信息                     |
| -------- | ---------------------- | ---------------------------- |
| 外部信息 | 交互信息（服务消息等） | 功能（继承、类结构等）       |
| 内部信息 | 行为信息（状态机）     | 结构信息（属性、业务逻辑等） |

内部：工作方法、工作机制

早晚都要考虑，早考虑更好。

一个完整、可评审设计的最小集。

有无足够信息判断设计是否有问题？缺失，则无法评审，是设计不足。

#### PSP 设计模板

OST FST SST LST

#### OST 操作规格模板

描述系统与外界的交互，描述用户在正常异常情况下的交互。

#### FST 功能规格模板

系统对外接口，静态星系的描述

外部可见的属性和方法。

可能用形式化符号描述方法等行为

#### SST 状态规格模板

程序所有状态、状态转换、转换时的动作

内部、动态信息。

#### LST 逻辑规格模板

内部静态信息

可以使用伪代码描述。

伪代码可能一句对应一长段，更加简介，设计从更高层次、整体的角度来进行。

### UML 常用图

* 用例图
* 时序图
* 类图
* 状态机图

#### UML 和 PSP 设计模板的关系

* 用例图、时序图提供了 PSP 中 OST 同样的信息

* UML 时序图和类图所描述的类间关系以及对象之间的交互信息在 PSP 4 个设计模板中没有对应内容。

* UML 类图中记录的方法型构（signature），但是方法的行为没有描述，后者在 PSP 的 FST 中有相应的内容。

  型构（signature）：返回值类型、参数类型、参数顺序

* LST 描述静态逻辑，UML 中没有方法

* UML 状态图和 SST 的状态图类似，但是 SST 中关于状态、状态转换、动作，没有对应的 UML 图示方法。

  SST 要求列出所有状态，两两之间的关系

### 设计的层次：PSP 模板

系统需求和用户需求的差别是什么？

系统需求 = 用户需求，用户需要什么

产品需求：用来做什么。通过 FST OST 进行

高层设计：系统内部工作机制。通过 LST SST 进行

模块需求

模块规格说明——模块工作机制——模块源码。

### 设计验证方法

设计也可能引入错误，需要进行验证。

设计验证范围非常广（相对于代码）

#### 状态机验证

什么是正确的状态机？

* 消除死循环和陷阱状态

* 转换条件的完整性和正交性

  完整性：从 A 出发的所有条件组合被考虑到。

  正交性：从 A 到 B 必须要求同样条件（组合），B 唯一。

* 评价状态机是否体现设计意图

真值表进行判断。

#### 执行表验证

#### 跟踪表验证

* 尽可能使用符号化。符号化能将特例变为一般情况下正确。**避免特例**

* 优化用例组合

除此之外，跟踪表和执行表一样，是在其基础上进行优化

#### 正确性检验

当作数学定理，形式化推理验证。

对复杂的结构用跟踪表辅助

#### While - do 正确性

* condition 最终一定会变成 False（循环可以结束）

* condition False 时，循环体内所有变量是否未被修改

  循环控制变量可以在循环体产生其他作用，为假的时候不能改变

* condition True 时，单独循环结构与循环体再加一个循环结构执行结果必须一致

  ```python
  # 1
  while condition:
      states
      
  # 2
  while condition:
      states
      while condition:
          states
  
  # 1 and 2 should be the same.
  ```

# 团队工程开发

* 团队需求开发
* 团队设计
* 团队实现
* 团队集成
* 开发工作中验证和确认

## 需求开发

一切工程活动的基础

### 类别

* 客户需求
* 产品需求
* 产品组件需求

后二者只是范围和规模的差异。

客户需求是客户要解决的**问题**。围绕问题可以有多限制，这都是问题的一部分。

产品需求是**解决方案**。

### 需求获取

试图找到客户所面临的问题

诱导

### 需求汇总

* 整理多来源信息，识别缺失信息

* 解决冲突的需求

  责任推给开发方是更有可能的。

* 需求整理和转化

  转化：客户需求转化为产品需求

* 推导未显式描述的需求内容

### 需求验证

对需求进行分析和确认，确保符合使用者预期。

* 建立操作概念和相关的场景

  例如，选课是一个操作概念，若干个概念串起来就是一个操作场景，也叫用例。

* 分析需求

  操作概念和操作场景下的解决方案。不建立起操作概念和操作场景则没有意义。

* 确认需求

  客户签字毫无意义。

  确认是一系列的活动。

### 需求文档制作

需求文档是必要的文档。

#### 好的需求文档的特征

* 内聚特征

* 完整特征

  不完整，就不可评审，无法判断对错

* 源自特征

* 可跟踪特征

* ……

#### SRS （模板）

通过模板确保不遗漏信息。

## 团队设计

设计过程和 PSP 基本一致

需要额外考虑：

* 团队智慧的使用

  不同的人做不同的事情。尽可能让大家都

* 设计标准

* 设计复用

* 设计的可测试支持

  好的设计的要求。

* 设计的可用性支持

### 团队指挥

挑战：

* 确定整体架构之前很难分工
* 鼓励成员在讨论和评审会议中的参与程度

## 集成

### 策略

* 大爆炸集成

  pros：每一个模块质量比较好时，最经济有效、最快的手段

  cons：定位错误困难

* 逐一添加集成

  pros：定位错误简单

  cons：不经济，成本高。第一个组件被测试的数量过多。

  采取自动化手段（持续集成）

  自动化测试无法测功能，只是单元测试或者单元测试 plus，本质上还是单元测试，对功能级别的问题无法发现。

  质量要求高的时候，自动化测试也没什么用。

* 集簇集成
  
  自底向上的策略。小的模块集簇，之后再把簇集成。
  
  cons：系统性错误只能在最后才被发现，这可能把前面的努力全部推翻
  
* 扁平化策略

  打桩。

  先把系统搭建起来，没有的模块用桩代替。系统的行为可以检测。
  
  集成时将打桩的模块逐步替换。
  
  合集簇相反，系统级错误尽早暴露，这也是缺点，固定的返回值，系统的描述非常单一。（比如，固定返回值是 True ，则另一半情况就被忽略了）

实际上的集成会混合，情况复杂。例如，依赖于别人的某个组件。各组件的质量状况都非常不确定。

通过集成计划来制定。

## V & V 验证与确认

验证 Verification

确认 Validation

#### 区别

对比客户需求合产品需求

验证（verification）保证**解决方案**被正确得实现，即产品是否和需求一致。（文档是否被正确得转化为了软件产品，即解决方案被实现）

确认（validation）针对客户需求，检验客户的需求（问题）被解决了。确保开发完成的产品或组件在环境中工作正确。

先保证解决方案被实现，再看是否解决了客户问题。

**Validation** is the process of checking whether the specification captures the customer's needs, while **verification** is the process of checking that the software meets the specification.

#### 常见软件开发流程属于哪个

集成和单元测试属于验证。

验收主要目的是判断用户的问题是否解决（应该是确认），通过功能的操作。

需求评审是确认，基于操作概念、场景，判断设计的解决方案能否帮用户解决问题。

| 验证（verification） | 确认（validation） |
| -------------------- | ------------------ |
| 集成测试             | 产品验收           |
| 单元测试             | 需求评审           |

大概上说，一头一尾确认，中间验证。

正确的理解是，这两个活动**贯穿**于软件开发的**始终**。

例如，验收测试中要通过参考解决方案的是否落实，尽管最终的结论是进行确认。

不局限于缺陷消除的阶段。

他们看起来差不多，但是**角度**不一样，所以结论不一样（方案被正确得实现了 or 用户的问题得到了很好的解决）

### 验证和确认活动

#### 环境准备

真实环境很重要。不过很多情况下不可能是真实环境。很多情况下在真实环境进行测试造成灾难性后果。

严格上要把场景的差异参数化，构建模型对模拟场景进行修正。

验收必须要考虑环境

#### 对象选择

重要**工作产品**其中的子集——**产品**

#### 结果分析

获得基本的结论：质量是否过关。

明确描述质量状况。

# 项目支持活动

* 配置管理
* 度量和分析
* 决策分析

对所有其他的活动的支撑。

## 配置管理

确保管理对象，工作产品的完整性（integration）和一致性

完整性不是指多、全面，而是强调一个整体。

#### 基本概念

* 配置项

* 基线

为了确保完整性，需要定义，“完整”需要哪些工作产品。例如，会议记录缺失了，产品也是完整的。即先定义完整的产品应该包含哪些内容，其中的每一项都叫做“配置项”。

识别出来配置项，要确保在开发中配置项的修改需要经过审核不可以随意修改，以此确保完整、一致。

识别配置项不是把所有东西都管控，而是去掉不那么重要的工作产品，限制配置项数量，只需要确保这些配置项是同步的。

基线是配置项的组合，包含真实基线和基线计划。在到达某个时间点的时候包含了哪些配置项。在项目的开发进展的重要时间点（和里程碑一致），所有的确认的配置项的组合叫做基线。

### 配置管理活动

代码算一个配置项还是多个配置项？如果是一个配置项，则只允许串行修改，确保版本。一个极端是所有代码当一个配置项管理——只能串行修改。另一个是每个文件都是一个配置项，则太多，配置项的目的就是为了限制管理的产品数量。实际上主要按照**模块**划分，一个模块一个配置项。

也由于进行了这种折中，所以可能发生错误，就需要进行配置审计。

版本管理不是配置管理。变更请求很重要，是对配置项的变动进行的管控。

完成单元测试就算是稳定版本，因为集成过程中需要配置管理。持续集成需要版本控制，因为每次未必成功，失败则需要回滚到之前成功的版本。

